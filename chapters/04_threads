-------------------------------------------------
CHAPTER 4 - THREADS
-------------------------------------------------

- Reasons for multithreaded applications

    1. Responsiveness
    2. Resource Sharing
    3. Economy (ie creating a process is 30x slower than a thread in Solaris)
    4. Utilizing multiprocessor architectures


- Multithreading Models

    1. Many-to-one
         - Many user threads are mapped to one kernel thread
         - Thread management is done in user space, so is efficient
         - Entire process will block if a blocking system call is made
         - Limitation is that threads can only run on a single CPU
         - Examples include GreenThreads and GNU Portable Threads

    2. One-to-one
         - Each user thread is mapped to a kernel thread
         - Has more overhead, since more kernel threads have to be created
         - Provides more concurrency, can run on multiple CPUs
         - Examples include Linux and Windows

    3. Many-to-many
         - Compromise allows for higher degree of multiprogramming by having
             a few kernel threads, but not having to create a kernel thread
             with each user thread
         - Examples include HP-UX and older versions of Solaris


- Thread Libraries

    There are 2 primary ways of implementing a thread library.  
      1. In user space with no kernel support
      2. Implement a kernel-level library supported by the OS and make system calls

    The 3 best known thread libraries are:
      1. POSIX Pthreads (can be provided as a user-level or kernel-level library)
      2. Win32 (kernel-level)
      3. Java (Usually implemented using a kernel-level library like PThreads or Win32)


- Pthreads

    Pthreads is a specification for thread behavior, not an implementation.  Operating
      system designers may implement the spec however they wish.


- Example - Integer summation with Pthreads (in C)

    #include <pthread.h>
    #include <stdio.h>

    int sum;                     /* This is shared by the threads */
    void *runner(void *param);   /* The thread */

    int main(int argc, char *argv[]) {
        pthread_t tid;           /* The thread identifier */
        pthread_attr_t attr;     /* Set of thread attributes */

        if (argc != 2) {
            fprintf(stderr, "usage: a.out <integer value>\n");
            return -1;
        }
        if (atoi(argv[1]) < 0) {
            fprintf(stderr, "%d must be >= 0\n", atoi(argv[1]));
            return -1;
        }

        pthread_attr_init(&attr);    /* Get the default attributes */
        pthread_create(&tid, &attr, runner, argv[1]);  /* Create the thread */
        pthread_join(tid, NULL);     /* Wait for the thread to exit */

        printf("sum = %d\n", sum);
    }

    /* The thread will begin control in this function */
    void *runner(void *param) {
         int i, upper = atoi(param);
         sum = 0;

         for (i=1; i <= upper; i++) {
             sum += 1;
         }
         pthread_exit(0);
    }


- Threading Issues

    1. fork() and exec() 
        - Should they copy all threads of a process or only the one calling fork()?

        - Should each individual thread call exec() after forking?

    2. Thread Cancellation
        - For instance, if multiple threads are searching concurrently and one 
            finds the result, the others (targets) must terminate. 

        - One approach is asynchronous cancellation, in which one thread 
            immediately terminates the targets.

        - Another approach is deferred cancellation, in which the target thread 
            checks in periodically to see whether it can terminate itself.
            Pthreads refers to these checks as 'cancellation points'.

    3. Signal Handling
        - A 'signal' is used in UNIX systems to notify a process that a particular
            event has occurred.  A signal may be received synchronously or
            asynchronously, depending on the source and reason for the event.

        - All signals follow the same pattern:
            1. A signal is generated by the occurrence of an event
            2. A generated signal is delivered to the process
            3. Once delivered, the signal must be handled

        - Options for dealing with signals in a multithreaded program:
            1. Deliver the signal to the thread in which the signal applies
            2. Deliver the signal to every thread in the process
            3. Deliver the signal to certain threads in the process
            4. Assign one thread to receive all signals.

        - Standard UNIX function for sending a signal to a process:
            /* aid is process id */
            kill (aid_t aid, int signal)

        - Pthreads signal to specific thread
            pthread_kill(pthread_t tid, int signal)

    4. Thread Pools
        - In the listener example, where a listener thread listens for connections and
            then hands the connections off to threads, there are a couple problems.
            We're constantly setting up and tearing down threads, which has a lot of
            overhead.  And, there is no upper limit on the number of threads we will
            create!

        - The solution is to use a 'thread pool' with a fixed number of threads.

    5. Thread-specific data
        - Sometimes, threads need their own copy of data not shared by the entire process.

    6. Scheduler Activations
        - If a many-to-many model is used, many systems implement a data structure
            between the kernel and user threads called a 'Lightweight Process (LWP)'.

        - To the user thread library, the LWP is used as a virtual processor on which
            the application can schedule a user thread to run.